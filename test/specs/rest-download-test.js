// Tests for the crocodoc document API
var API = require('api/download');
var fs = require('fs');

// setup the common rest response tests
var restTests = framework.restTests(it);
var _200Checks = restTests._200Checks;
var _400Checks = restTests._400Checks;
var _JsonContentChecks = restTests._JsonContentChecks;

// alias for brevity
var pollTimeout = framework.timeouts.poll;
var responseTimeout = framework.timeouts.response;
var downloadTimeout = pollTimeout;
var fsUtils = framework.fsUtils;

// make sure we clean temporarily created uuids
after(function(done) {
  this.timeout(responseTimeout * (framework.tempUuid.uuids.length+1));
  framework.tempUuid.purge(done);
});

var simplePresentation = 'test/support/files/simple-presentation.ppt';
var nonexistentUuid = 'non-existent-Uuid';

describe('Crocodoc API: REST: download', function() {
  var instance = new API(framework.crocodoc.token);
  var preloadedUuid;

  it('should preload a file without timing out', function(done) {
    this.timeout(pollTimeout);
    framework.tempUuid.fromFile(simplePresentation, function(e, r, b) {
      framework.assert(typeof b.uuid === 'string', 'Could not pre-load a document for the tests');
      preloadedUuid = b.uuid;
      framework.tempUuid.waitFor(preloadedUuid, done);
    });
  });

  describe('.document()', function() {
    describe('with a uuid for a preloaded file', function() {
      describe('when downloading a pdf', function() {
        var uuid, error, response, body, filepath;

        it('should respond without timing out', function(done) {
          this.timeout(downloadTimeout);

          uuid = preloadedUuid;
          filepath = framework.tempFile(uuid+'-pdf.pdf');
          var ws = fsUtils.writeStream(filepath);

          instance.document(uuid, {pdf: true}, ws, function(e, r, b) {
            error = e;
            response = r;
            body = b;
            done();
          });
        });

        _200Checks(function(){return error;}, function(){return response;}, function(){return body;});
        _JsonContentChecks(function(){return error;}, function(){return response;}, function(){return body;}, true);

        it('should have created a non-zero sized file', function() {
          var filesize = fsUtils.fileSize(filepath);
          framework.assert( filesize > 0, 'Expected filesize for "'+filepath+'" to be greater than zero, not: '+filesize);
        });

        describe('the response body generated by the library', function() {
         it('should have a non-empty uuid string field', function() {
            framework.assert(typeof body.uuid === 'string' && body.uuid.length > 0, 'Expected body.uuid to be a non-empty string, not: ('+typeof body.uuid+'): '+body.uuid);
          });
        });
      });

      describe('when downloading the original', function() {
        var uuid, error, response, body, filepath;

        it('should respond without timing out', function(done) {
          this.timeout(downloadTimeout);

          uuid = preloadedUuid;
          filepath = framework.tempFile(uuid+'-original'+framework.path.extname(simplePresentation));
          var ws = fsUtils.writeStream(filepath);

          instance.document(uuid, ws, function(e, r, b) {
            error = e;
            response = r;
            body = b;
            done();
          });
        });

        _200Checks(function(){return error;}, function(){return response;}, function(){return body;});
        _JsonContentChecks(function(){return error;}, function(){return response;}, function(){return body;}, true);

        it('should have created a non-zero sized file', function() {
          var filesize = fsUtils.fileSize(filepath);
          framework.assert( filesize > 0, 'Expected filesize for "'+filepath+'" to be greater than zero, not: '+filesize);
        });

        describe('the response body generated by the library', function() {
         it('should have a non-empty uuid string field', function() {
            framework.assert(typeof body.uuid === 'string' && body.uuid.length > 0, 'Expected body.uuid to be a non-empty string, not: ('+typeof body.uuid+'): '+body.uuid);
          });
        });
      });
    });

    describe('with a non-existent uuid', function() {
      describe('when downloading a pdf', function() {
        var uuid, error, response, body, filepath;

        it('should respond without timing out', function(done) {
          this.timeout(downloadTimeout);

          uuid = nonexistentUuid;
          filepath = framework.tempFile(uuid+'-pdf.pdf');
          var ws = fsUtils.writeStream(filepath);

          instance.document(uuid, {pdf: true}, ws, function(e, r, b) {
            error = e;
            response = r;
            body = b;
            done();
          });
        });

        _400Checks(function(){return error;}, function(){return response;}, function(){return body;});
        _JsonContentChecks(function(){return error;}, function(){return response;}, function(){return body;});

        it('should have created a zero sized file', function() {
          var filesize = fsUtils.fileSize(filepath);
          framework.assert( filesize <= 0, 'Expected filesize for "'+filepath+'" to be zero, not: '+filesize);
        });

        describe('the response body returned from the API', function() {
         it('should have a truthy error field', function() {
            framework.assert(body.error , 'Expected body.error to be truthy, not: ('+typeof body.error+'): '+body.error);
          });
        });
      });

      describe('when downloading the original', function() {
        var uuid, error, response, body, filepath;

        it('should respond without timing out', function(done) {
          this.timeout(downloadTimeout);

          uuid = nonexistentUuid;
          filepath = framework.tempFile(uuid+'-original'+framework.path.extname(simplePresentation));
          var ws = fsUtils.writeStream(filepath);

          instance.document(uuid, ws, function(e, r, b) {
            error = e;
            response = r;
            body = b;
            done();
          });
        });

        _400Checks(function(){return error;}, function(){return response;}, function(){return body;});
        _JsonContentChecks(function(){return error;}, function(){return response;}, function(){return body;});

        it('should have created a zero sized file', function() {
          var filesize = fsUtils.fileSize(filepath);
          framework.assert( filesize <= 0, 'Expected filesize for "'+filepath+'" to be zero, not: '+filesize);
        });

        describe('the response body returned from the API', function() {
         it('should have a truthy error field', function() {
            framework.assert(body.error , 'Expected body.error to be truthy, not: ('+typeof body.error+'): '+body.error);
          });
        });
      });
    });
  });

  describe('.thumbnail()', function() {
    describe('with a uuid for a preloaded file', function() {
      var uuid, error, response, body, filepath;

      it('should respond without timing out', function(done) {
        this.timeout(downloadTimeout);

        uuid = preloadedUuid;
        filepath = framework.tempFile(uuid+'-thumbnail.png');
        var ws = fsUtils.writeStream(filepath);

        instance.thumbnail(uuid, "150x150", ws, function(e, r, b) {
          error = e;
          response = r;
          body = b;
          done();
        });
      });

      _200Checks(function(){return error;}, function(){return response;}, function(){return body;});
      _JsonContentChecks(function(){return error;}, function(){return response;}, function(){return body;}, true);

      it('should have created a non-zero sized file', function() {
        var filesize = fsUtils.fileSize(filepath);
        framework.assert( filesize > 0, 'Expected filesize for "'+filepath+'" to be greater than zero, not: '+filesize);
      });

      describe('the response body generated by the library', function() {
       it('should have a non-empty uuid string field', function() {
          framework.assert(typeof body.uuid === 'string' && body.uuid.length > 0, 'Expected body.uuid to be a non-empty string, not: ('+typeof body.uuid+'): '+body.uuid);
        });
      });
    });

    describe('with a non-existent uuid', function() {
      var uuid, error, response, body, filepath;

      it('should respond without timing out', function(done) {
        this.timeout(downloadTimeout);

        uuid = nonexistentUuid;
        filepath = framework.tempFile(uuid+'-thumbnail.png');
        var ws = fsUtils.writeStream(filepath);

        instance.thumbnail(uuid, "150x150", ws, function(e, r, b) {
          error = e;
          response = r;
          body = b;
          done();
        });
      });

      _400Checks(function(){return error;}, function(){return response;}, function(){return body;});
      _JsonContentChecks(function(){return error;}, function(){return response;}, function(){return body;});

      it('should have created a zero sized file', function() {
        var filesize = fsUtils.fileSize(filepath);
        framework.assert( filesize <= 0, 'Expected filesize for "'+filepath+'" to be zero, not: '+filesize);
      });

      describe('the response body returned from the API', function() {
       it('should have a truthy error field', function() {
          framework.assert(body.error , 'Expected body.error to be truthy, not: ('+typeof body.error+'): '+body.error);
        });
      });
    });
  });

  describe('.text()', function() {
    describe('with a uuid for a preloaded file', function() {
      var uuid, error, response, body, filepath;

      it('should respond without timing out', function(done) {
        this.timeout(downloadTimeout);

        uuid = preloadedUuid;
        filepath = framework.tempFile(uuid+'-text.txt');
        var ws = fsUtils.writeStream(filepath);

        instance.text(uuid, ws, function(e, r, b) {
          error = e;
          response = r;
          body = b;
          done();
        });
      });

      _200Checks(function(){return error;}, function(){return response;}, function(){return body;});
      _JsonContentChecks(function(){return error;}, function(){return response;}, function(){return body;}, true);

      it('should have created a non-zero sized file', function() {
        var filesize = fsUtils.fileSize(filepath);
        framework.assert( filesize > 0, 'Expected filesize for "'+filepath+'" to be greater than zero, not: '+filesize);
      });

      describe('the response body generated by the library', function() {
       it('should have a non-empty uuid string field', function() {
          framework.assert(typeof body.uuid === 'string' && body.uuid.length > 0, 'Expected body.uuid to be a non-empty string, not: ('+typeof body.uuid+'). body: '+framework.inspect(body));
        });
      });
    });

    describe('with a non-existent uuid', function() {
      var uuid, error, response, body, filepath;

      it('should respond without timing out', function(done) {
        this.timeout(downloadTimeout);

        uuid = nonexistentUuid;
        filepath = framework.tempFile(uuid+'-text.txt');
        var ws = fsUtils.writeStream(filepath);

        instance.text(uuid, ws, function(e, r, b) {
          error = e;
          response = r;
          body = b;
          done();
        });
      });

      _400Checks(function(){return error;}, function(){return response;}, function(){return body;});
      _JsonContentChecks(function(){return error;}, function(){return response;}, function(){return body;});

      it('should have created a zero sized file', function() {
        var filesize = fsUtils.fileSize(filepath);
        framework.assert( filesize <= 0, 'Expected filesize for "'+filepath+'" to be  zero, not: '+filesize);
      });

      describe('the response body returned from the API', function() {
       it('should have a truthy error field', function() {
          framework.assert(body.error , 'Expected body.error to be truthy, not: ('+typeof body.error+'): '+body.error);
        });
      });
    });
  });
});
